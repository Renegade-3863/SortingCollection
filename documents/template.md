## 记录一些写这个小型项目时遇到的问题
### 关于模板函数的实现问题
- 一般建议是把模板函数的定义和声明都写到.hpp文件中，声明和定义分离开来很容易链接报错(顺带一提C++的STL模板库都是这么做的，所以我认为这么写应该问题不大)

&emsp; 个人对于这一问题的看法是，编译器对模板函数和普通函数的处理方法并不相同，模板函数只有在定义内容对于编译器可见时，才会在编译器生成对应类型的实例；

&emsp; 换个角度来说，如果进行模板函数声明和定义的分离，由于C++的编译是各源文件独立进行的，只生成了对应的可重定位对象文件(即.o文件)，这些文件互相拥有的定义都是互相间不可见的，而只有在链接阶段，链接器才会尝试把代码进行整合(注意链接阶段并不会有任何新代码的生成，链接器只是把对应的函数符号和函数定义进行了地址映射，使得符号有对应的寻址位置)，而所谓的函数模板，无论是编译器还是链接器，都不会把它当作一段可执行代码看待，而又只有编译器能够做到(在模板定义可见的情况下)根据源文件中的模板实例化语句生成对应的实际函数代码，然而上面我们提到，由于我们把模板函数的定义分离到了另一个源文件中，此时引用了包含函数模板的头文件的那个源文件的作用域内就不包含对应函数模板的定义，编译器就找不到对应的用于生成实例的模板定义了，注意此时编译器不会报错终止，它只会用一个符号替代该实例化函数，因而报错会在链接阶段出现。

### 关于function模板类的使用问题
- 如果要在某个用function模板定义的函数中使用其他使用function模板定义的函数，那么在对应的lambda catch语句中需要使用按值/按引用捕获上文的对应函数(&/=)，函数本身嵌套调用也一样(因为一个lambda函数可以看见的范围只有它捕获的东西和传给它的东西)

### CMakeLists.txt中 PROJECT_SOURCE_DIR 宏和 CMAKE_CURRENT_SOURCE_DIR 宏的关系
- 二者不等价，只是一般情况下指向的路径相同
- **PROJECT_SOURCE_DIR** 指向的是距离当前CMakeLists.txt文件最近的一个包含project()命令的CMakeLists.txt文件所在的目录(包括当前所在的CMakeLists.txt文件)
- **CMAKE_CURRENT_SOURCE_DIR** 指向的是当前工作的CMakeLists.txt文件的所在目录